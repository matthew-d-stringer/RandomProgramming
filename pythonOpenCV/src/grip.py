import cv2
import numpy
import math
from enum import Enum

class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.font = cv2.FONT_HERSHEY_COMPLEX

        self.__hsv_threshold_hue = [17.805755395683452, 118.5665529010239]
        self.__hsv_threshold_saturation = [32.10431654676259, 255.0]
        self.__hsv_threshold_value = [34.39748201438849, 255.0]

        self.hsv_threshold_output = None

        self.__find_contours_input = self.hsv_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__convex_hulls_contours = self.find_contours_output

        self.convex_hulls_output = None


    def sortByX(self, contour):
        def findX(cnt):
            x,y,w,h = cv2.boundingRect(cnt)
            return x
        sortedVals = sorted(contour, reverse=False, key=findX)
        return sortedVals
    def sortByHeight(self, contour, cols):
        def findHeight(cnt):
            x,y,w,h = cv2.boundingRect(cnt)
            return int(h*math.exp(-(x-cols/2)**2*cols**(-2))) #returns the centermost and tallest contour
        sortedVals = sorted(contour, reverse=True, key=findHeight)
        return sortedVals

    def findLeftAndRightContour(self, output, leftContours, cContour, rightContours,rows):

        def findRightContour(rightCnts, rows, leftX, leftH):
            exitNorm = False
            print("leftx: "+str(leftX))
            for i in range(len(rightCnts)):
                contour = rightCnts[i]
                x,y,w,h = cv2.boundingRect(contour)
                cv2.rectangle(output, (x,y), (x+w,y+h),(255,0,0),2)
                print("rightx: "+str(x))
                if x < leftX or abs(leftH-h) > rows/4:
                    print("skipped")
                    exitNorm = False
                    continue
                exitNorm = True
                break
            print("exit norm: "+str(exitNorm))
            return exitNorm,x,y,w,h

        if cContour >= len(leftContours):
            return False, 0,0,0,0, 0,0,0,0
        leftCnt = leftContours[cContour]
        x,y,w,h = cv2.boundingRect(leftCnt)
        exitNorm,rx,ry,rw,rh = findRightContour(rightContours,rows,x,h)
        if not exitNorm:
            return self.findLeftAndRightContour(output, leftContours, cContour+1, rightContours, rows)
        return True, x,y,w,h, rx,ry,rw,rh

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step HSV_Threshold0:
        self.__hsv_threshold_input = source0
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)

        # Step Find_Contours0:
        self.__find_contours_input = self.hsv_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        # Step Convex_Hulls0:
        self.__convex_hulls_contours = self.find_contours_output
        (self.convex_hulls_output) = self.__convex_hulls(self.__convex_hulls_contours)

        self.contoursOut = self.convex_hulls_output

        output = source0.copy()
        cv2.drawContours(output, self.contoursOut, -1, (0, 0, 255), 1)

        self.contourNum = len(self.contoursOut)

        # sortedByX = self.sortByX(self.contoursOut)
        sortedByHeight = self.sortByHeight(self.contoursOut, source0.shape[1])

        leftContours = []
        rightContours = []
        for i in range(0, len(self.contoursOut)):
            contour = sortedByHeight[i]
            rows,cols = output.shape[:2]
            [vx,vy,x,y] = cv2.fitLine(contour, cv2.DIST_L2,0,0.01,0.01)
            if vx < 0.02 and vx > -0.02:
                direction ="null"
            elif vy/vx > 0:
                direction = "right"
                rightContours.append(contour)
            elif vy/vx < 0:
                direction = "left"
                leftContours.append(contour)
            cv2.putText(output, direction,(x,y), self.font, 1,(255,0,0))
        rightContoursByX = self.sortByX(rightContours)
        worked, lx,ly,lw,lh, rx,ry,rw,rh = self.findLeftAndRightContour(output, leftContours, 0, rightContoursByX, rows)
        if not worked:
            print("did not work")
            return output
        cv2.rectangle(output, (lx, ly), (lx+lw,ly+lh),(255,0,0),2)
        
        cv2.putText(output, "decided left",(lx,ly+lh-10), self.font, 0.5,(255,0,0))
        cv2.putText(output, "decided right",(rx,ry+rh-10), self.font, 0.5,(255,0,0))

        return output


    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod
    def __convex_hulls(input_contours):
        """Computes the convex hulls of contours.
        Args:
            input_contours: A list of numpy.ndarray that each represent a contour.
        Returns:
            A list of numpy.ndarray that each represent a contour.
        """
        output = []
        for contour in input_contours:
            output.append(cv2.convexHull(contour))
        return output



